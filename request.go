package bitcocheck

import (
	"bytes"
	"crypto/hmac"
	"crypto/sha256"
	"encoding/hex"
	"fmt"
	"io/ioutil"
	"log"
	"net/http"
	"time"
)

type APIInfo struct {
	Access string
	Secret string
	Nonce  string
	Url    string
	Body   string
	Debug  bool
}

func NewAPIInfo(access, secret, url, body string, debug bool) APIInfo {
	// now := time.Now().Unix()
	now := time.Now().UnixNano()
	return APIInfo{
		Access: access,
		Secret: secret,
		Nonce:  fmt.Sprintf("%d", now),
		Url:    url,
		Body:   body,
		Debug:  debug,
	}
}

func (a APIInfo) Signature() string {
	mac := hmac.New(sha256.New, []byte(a.Secret))
	msg := fmt.Sprintf("%s%s%s", a.Nonce, a.Url, a.Body)
	mac.Write([]byte(msg))
	return hex.EncodeToString(mac.Sum(nil))
}

func (a APIInfo) Request() ([]byte, error) {

	// Generated by curl-to-Go: https://mholt.github.io/curl-to-go
	var buf []byte
	req, err := http.NewRequest("GET", a.Url, nil)
	if err != nil {
		// handle err
		return buf, err
	}
	signature := a.Signature()
	req.Header.Set("Access-Key", a.Access)
	req.Header.Set("Access-Nonce", a.Nonce)
	req.Header.Set("Access-Signature", signature)
	if a.Debug {
		log.Println(a.Url)
	}
	resp, err := http.DefaultClient.Do(req)
	if err != nil {
		// handle err
		return buf, err
	}
	defer resp.Body.Close()

	buf, err = ioutil.ReadAll(resp.Body)
	if err != nil {
		log.Fatal(err)
	}

	return buf, nil
}

func (a APIInfo) PostRequest() ([]byte, error) {
	var buf []byte
	payload := bytes.NewReader([]byte(a.Body))
	req, err := http.NewRequest("POST", a.Url, payload)
	if err != nil {
		return buf, err
	}
	signature := a.Signature()
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("Access-Key", a.Access)
	req.Header.Set("Access-Nonce", a.Nonce)
	req.Header.Set("Access-Signature", signature)
	if a.Debug {
		log.Println(a.Url)
	}
	resp, err := http.DefaultClient.Do(req)
	if err != nil {
		return buf, err
	}
	defer resp.Body.Close()
	buf, err = ioutil.ReadAll(resp.Body)
	if err != nil {
		log.Fatal(err)
	}

	return buf, nil
}

func (a APIInfo) Delete() ([]byte, error) {

	// Generated by curl-to-Go: https://mholt.github.io/curl-to-go
	var buf []byte
	req, err := http.NewRequest("DELETE", a.Url, nil)
	if err != nil {
		// handle err
		return buf, err
	}
	signature := a.Signature()
	req.Header.Set("Access-Key", a.Access)
	req.Header.Set("Access-Nonce", a.Nonce)
	req.Header.Set("Access-Signature", signature)
	if a.Debug {
		log.Println(a.Url)
	}
	resp, err := http.DefaultClient.Do(req)
	if err != nil {
		// handle err
		return buf, err
	}
	defer resp.Body.Close()

	buf, err = ioutil.ReadAll(resp.Body)
	if err != nil {
		log.Fatal(err)
	}

	return buf, nil
}
